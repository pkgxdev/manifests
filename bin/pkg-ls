#!/usr/bin/env -S pkgx +git deno run -R --allow-run

import { backticks_quiet, platform_partial_path } from "brewkit";
import { fromFileUrl } from "jsr:@std/path@1/from-file-url";
import { parse } from "jsr:@std/yaml@1/parse";

if (import.meta.main) {
    for await (const project of ls()) {
        if (Deno.args.includes("--print-paths")) {
            const path = fromFileUrl(new URL(`../projects/${project}/package.yml`, import.meta.url));
            console.log(path);
        } else {
            console.log(project)
        }
    }
}

export default function *ls() {
    const log = backticks_quiet`git log --name-only --pretty=format:'%H' --reverse`;

    const projects = log
        .split(/\s+/)
        .filter(x => x.endsWith("/package.yml"))
        .map(x => x.replace(/^projects\//, "")
        .replace(/\/package.yml$/, ""));

    const set = new Set();
    for (const project of projects) {
        if (project == "deno.com") continue;
        if (set.has(project)) continue;
        set.add(project);
        if (Deno.args.includes("--platforms=all") || builds_on_this_platform(project)) {
            yield project;
        }
    }

    function builds_on_this_platform(project: string) {
        const filename = fromFileUrl(new URL(`../projects/${project}/package.yml`, import.meta.url));
        const data = Deno.readTextFileSync(filename);
        const yaml = (parse(data) as any).platforms;
        if (!Array.isArray(yaml) || yaml.length == 0) return false;
        if (yaml.includes("*")) return true;
        if (yaml.includes(Deno.build.os)) return true;
        if (yaml.includes(platform_partial_path())) return true;
        return false;
    }
}
